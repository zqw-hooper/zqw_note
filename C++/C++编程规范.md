# C++ 编程规范学习 (Google)

[google编程规范](https://blog.csdn.net/Hhrock/article/details/82386014)

## 头文件:
1. **`#define`保护**
    所有的有文件都应该使用`#define`来防止头文件被多重包含,为了保证唯一性,头文件的命名应该基于所在源代码树的全路径.
2. **前置声明:**
    尽可能地避免使用前置声明。使用 #include 包含需要的头文件即可。
3. **内联函数:**
    只有当函数只有 10 行甚至更少时才将其定义为内联函数.
    > 当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.
4. **`#include`的路径及顺序**
   
## 作用域:
1. **命名空间:**
   - 在命名空间的最后注释出命名空间的名字.
   - 用命名空间把文件内容封装起来.
   - 不应该使用`using`指示引入整个命名空间的标识符号, 因为会污染命名空间.
   - 不要在头文件中使用命名空间别名,因为任何在头文件中引入的命名空间都会成为公开API的一部分.
   - 禁止用内联命名空间
2. **匿名命名空间和静态变量:**
    在c文件中定义一个不需要被外部引用的变量时，可以将它们放在匿名命名空间或声明为`static`。但是不要在.h文件中这么做。
    > 所有置于匿名命名空间的声明都具有内部链接性，函数和变量可以经由声明为 static 拥有内部链接性，这意味着你在这个文件中声明的这些标识符都不能在另一个文件中被访问。即使两个文件声明了完全一样名字的标识符，它们所指向的实体实际上是完全不同的。
3. **非成员函数、静态成员函数和全局函数:**
    使用静态成员函数或命名空间内的非成员函数, 尽量不要用裸的全局函数. 将一系列函数直接置于命名空间中，不要用类的静态方法模拟出命名空间的效果，类的静态方法应当和类的实例或静态数据紧密相关.
    > 某些情况下, 非成员函数和静态成员函数是非常有用的, 将非成员函数放在命名空间内可避免污染全局作用域.
4. **局部变量:**
    将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化.
5. **静态和全局变量:???**

## 类:
1. **构造函数的职责:**
    不要在构造函数中调用虚函数, 也不要在无法报出错误时进行可能失败的初始化.
2. **隐式类型转换:**
   [隐式转换含义](https://www.cnblogs.com/rookiezjz/p/12357869.html)
    在类型定义中, 类型转换运算符和单参数构造函数都应当用`explicit`进行标记. 一个例外是, 拷贝和移动构造函数不应当被标记为`explicit`, 因为它们并不执行类型转换. 
3. **可拷贝类型和可移动类型:??**

4. **结构体 VS. 类:**    
    当只有数据成员时使用`struct`, 其它一概使用`class`.
5. **继承:**
    - 所有继承必须是`public`的. 
    - 必要的话, 析构函数声明为`virtual`. 如果你的类有虚函数, 则析构函数也应该为虚函数.
    - 对于可能被子类访问的成员函数, 不要过度使用`protected`关键字. 注意, 数据成员都必须是私有的.
    - 在声明重载时, 请使用`override`, `final`或`virtual`的其中之一进行标记. 
6. **多重继承:**
    只有当所有父类除第一个外都是**纯接口类**时, 才允许使用多重继承. 为确保它们是纯接口, 这些类必须以`Interface`为后缀.
    > 多重继承允许子类拥有多个基类. 要将作为纯接口的基类和具有实现的基类区别开来.
7. **接口:???**
8. **运算符重载:**
    只有在意义明显, 不会出现奇怪的行为并且与对应的内建运算符的行为一致时才定义重载运算符. 
9. **存取控制:**
    将所有的数据成员声明为`private`.
10. **声明顺序:**
    将相似的声明放在一起, 将`public`部分放在最前.

## 函数:
1. **参数顺序::**
    函数的参数顺序: 输入参数在先,后跟输出参数.
2. **编写简短函数:**
    倾向于编写简短,凝练的函数.
3. **引用参数:**
   **所有按引用传递的参数必须加上`const`. 
   > Google Code 硬性约定:**函数的输入参数是值参或`const`引用, 输出参数为指针**
   > 引用在语法上是值变量却拥有指针的语义.
4. **函数重载::**
    若要使用函数重载, 则必须能让读者一看调用点就胸有成竹, 而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数.
5. **缺省参数:**
    [缺省参数含义](https://www.jianshu.com/p/7db4010f7476)
    只允许在非虚函数中使用缺省参数, 且必须保证缺省参数的值始终一致. 
6. **函数返回类型后置语法:**
    只有在常规写法 (返回类型前置) 不便于书写或不便于阅读时使用返回类型后置语法.
    > C++11 引入了这一新的形式. 现在可以在函数名前使用 auto 关键字, 在参数列表之后后置返回类型. 例如:`auto foo(int x) -> int;`

## 其他 C++ 特性
1. **引用参数:**
    所有按引用传递的参数必须加上`const`.
2. **右值引用:** 
   [左右值含义](https://www.jianshu.com/p/d19fc8447eaa)
   > **区分左值和右值的便捷方法：看能不能对表达式取地址，如果能，则为左值，否则为右值.**
   > **左值引用只能绑定左值，右值引用只能绑定右值，如果绑定的不对，编译就会失败.**常量左值引用却是个奇葩，它可以算是一个“万能”的引用类型，它可以绑定非常量左值、常量左值、右值，而且在绑定右值的时候，常量左值引用还可以像右值引用一样将右值的生命期延长，缺点是，只能读不能改。
   [深浅拷贝含义](https://www.jb51.net/article/120922.htm)
3. **函数重载:**
    如果您打算重载一个函数, 可以试试改在函数名里加上参数信息。例如，用`AppendString()`和`AppendInt()`等，而不是一口气重载多个 `Append()`.
4. **缺省参数:**
    我们不允许使用缺省函数参数，少数极端情况除外。尽可能改用函数重载。
5. **变长数组和 `alloca()`:**
    不允许使用变长数组和`alloca()`.因为它们根据数据大小动态分配堆栈内存, 会引起难以发现的内存越界bugs.
6. **友元:**
    [友元含义](https://www.runoob.com/cplusplus/cpp-friend-functions.html)
    允许合理的使用友元类及友元函数.
7. **异常:**
    不使用 C++ 异常.
8. **运行时类型识别:??**
9. **类型转换:**
    使用C++的类型转换, 如`static_cast<>()`. 不要使用`int y = (int)x`或`int y = int(x)`等转换方式;
    > [C++类型转换含义](https://www.jianshu.com/p/5163a2678171)
10. **流:**
    不要使用流, 除非是日志接口需要. 使用`printf`之类的代替.
11. **前置自增和自减:**
    对于迭代器和其他模板对象使用前缀形式(`++i`)的自增, 自减运算符.
    > 不考虑返回值的话, 前置自增`++i`常要比后置自增`i++`效率更高. 因为后置自增 (或自减) 需要对表达式的值`i`进行一次拷贝.
12. **const 用法:**
    `const`变量, 数据成员, 函数和参数为编译时类型检测增加了一层保障; 便于尽早发现错误. 因此, 我们强烈建议在任何可能的情况下使用 `const`.
13. **constexpr 用法:???**
    在 C++11 里，用`constexpr`来定义真正的常量，或实现常量初始化.
14. **整型:**
    `<stdint.h>` 定义了`int16_t`, `uint32_t`, `int64_t`等整型, 在需要确保整型大小时可以使用它们代替`short`,`unsigned` `long long`等. 在C整型中, 只使用`int`. 在合适的情况下, 推荐使用标准类型如`size_t`和`ptrdiff_t`.
15. **64 位下的可移植性:??**
16. **预处理宏:**
    使用宏时要非常谨慎, 尽量以内联函数, 枚举和常量代替之.
17. **nullptr 和 NULL:**
    整数用 0, 实数用 0.0, 指针用`nullptr`或`NULL`, 字符 (串) 用 `'\0'`.
18. **sizeof:**
    尽可能用`sizeof(varname)`代替`sizeof(type)`.
19. **auto:**
    用`auto`绕过烦琐的类型名，只要可读性好就继续用，`auto`只能用在局部变量里用.
20. **列表初始化:**
    任何对象类型都可以被列表初始化.
    > Vector 接收了一个初始化列表。
    > `vector<string> v{"foo", "bar"};`
21. **Lambda 表达式:**
    适当使用 lambda 表达式.
    > Lambda 表达式是创建匿名函数对象的一种简易途径，常用于把函数当参数传.
    例如：std::sort(v.begin(), v.end(), [](int x, int y) {
    return Weight(x) < Weight(y);
    });
