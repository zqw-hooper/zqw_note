# C++基础-1

1. **\<cstdio>与<stdio.h>区别:**
   - stdio.h是C标准函数库中的头文件, stdio.h头文件将所有名字放在global namespace中.
   - cstdio是标准C++（STL）头文件, cstdio头文件将所有名字放在std namespace中.
2. **<>与" "区别:**
   - <>先去系统目录中找头文件，如果没有再到当前目录下找. 所以像标准的头文件 stdio.h和 stdlib.h等用这个方法.
   - " "首先在当前目录下寻找，如果找不到，再到系统目录中寻找. 这个用于include自定义的头文件，让系统优先使用当前目录中定义的.
3. **namespace介绍:**
   - C语言中只有一个全局作用域.
   > - C语言中所有的全局标识符/函数共享一个作用域, 
   > - 标识符之间可能发生冲突.

   - C++中引入namespace概念,即命名空间.
   > - 命名空间将全局作用域分成不同作用域.
   > - 不同命名空间中的标识符/函数可以同名而不发生冲突.
   > - 命名空间可以嵌套.
   > - 全局作用域也叫作默认命名空间.

   - 嵌套的命名空间:
   <img src="../image/screenshot_namespace.png" width="50%" height="50%" />
   <img src="../image/screenshot_namespace1.png" width="50%" height="50%" />

   using指令: 可以使用using namespace 指令告诉编译器后续代码正在使用那个命名空间中的标识符/函数.
4. **继承和派生类:**
   - 继承允许我们依据另一个类来定义一个类,这使得创建和维护一个应用程序变得更容易,也达到了重用代码功能和提高效率的效果.
   - 当创建一个类时,不需要重新编写成员变量和成员函数,只需要指定新建的类继承一个已有的类即可.这个已有的类称为基类, 新建的类称为派生类.
   例: 
      单继承:`class derived-class: public/protected/private base-class`  
      多继承: `class derived-class: public/protected/private base-class, public/protected/private base-class1`
   - 继承有三种继承类型:public, protected, private. 我们通常使用public.
     公有继承(public): 当一个类派生自公有基类时,基类的公有成员也是派生类的公有成员,基类的保护成员也是派生类的保护成员,基类的私有成员不能直接被派生类访问,但是可以通过调用基类的公有和保护成员来访问.
     保护继承(protected): 当一个类派生自保护基类时, 基类的公有和保护成员将称为派生类的保护成员.
     私有继承(private): 当一个类派生自私有基类时, 基类的公有和保护成员将成为派生类的私有成员.
5. **访问控制和继承:**
   **在没有继承的情况下，protected和private相同.**
    ![截图](../image/screenshot.png)
6. **重载运算符和重载函数:**  
   - 当调用一个重载函数或重载运算符时，编译器通过所使用的参数类型与定义中的参数类型进行对比,决定选用最合适的定义,选择最合适的重载函数或重载运算符的过程称为**重载决策**.
   - 重载函数: 在同一作用域内,可以声明几个功能类似的同名函数,但是这些函数的形参(个数或类型或顺序)必须不同.
   - 重载运算符: 可以重新定义或重载C++内置的大部分运算符.
      > 重载的运算符是带有特殊名称的函数,函数名是由关键字operator和其后要重载运算符符号构成的,与其他函数一样,重载运算符有一个返回类型和一个参数列表.例:`Box operator+(const Box& b)`
    <img src="../image/screenshot_operator.png" width="50%" height="50%" />
   - 上图例子中中的 if (p1 == p2) 语句，相当于对象p1调用函数“operator==”，把对象p2作为一个参数传递给该函数，从而实现了两个对象的比较。
7. **多态和虚函数:**
   <img src="../image/screenshot_duotai.png" width="50%" height="50%" />
   - 上图中导致输出错误的原因是调用函数area()被编译器设置为基类中的版本,这就是所谓的**静态多态**或**静态链接**-函数调用在程序执行前就已经设置好了,故也叫**早绑定**.
  
   <img src="../image/screenshot_duotai_virtual.png" width="50%" height="50%" />
   - 上图中输出正确结果原因是area()函数会在每个子类中具有不同的实现.这就是**多态**的一般使用方式.
   - 虚函数: 是在基类中使用关键字virtual声明的函数. 在派生类中重新定义基类中定义的虚函数时, 会告诉编译器不要静态链接到该函数, 这种操作称为**动态链接**或**后期绑定**.
   - 纯虚函数: 在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。
      > `virtual int area() = 0;` = 0 告诉编译器,函数没有主体, 是纯虚函数.
8. **数据抽象和数据封装:**
   - 数据抽象指只向外界提供关键信息,并隐藏实现细节.C++类为数据抽象提供了可能,其可以向外界提供用于操作的公有方法,外界实际上并不清楚类的内部实现.
   - 数据抽象和数据封装的好处:
     > 类的内部受到保护,不会因无意的用户级错误导致对象状态受损.
     > 类实现可能随着时间的推移而发生变化,以便对应不断变化的需求,或者应对那些要求不改变用户级代码的错误报告。
9. **预处理器:**
    - 预处理器是一些指令,指示编译器在实际编译之前所需完成的预处理.
    - 所有的预处理器指令都是以(#)开头,只有空格符可以出现在预处理器之前,预处理器指令不是C++语言,所以它们不会以分号(;)结尾.
      > `#include`指令用于把头文件包含到源文件中.
    - #define预处理指令用于创建符号常量,该符号常量通常被称为**宏**.
      > 例: `#define PI 3.14159`
    - 参数宏:使用#define来定义一个带参数的宏.
      > 例: `#define MIN(a,b) (a < b ? a : b)`
    - 条件编译: 可以用来有选择的对部分程序源代码进行编译.
      <img src="../image/screenshot_define.png" width="100%" height="100%" />
10. **信号处理:**
    - 信号是由操作系统传给进程的中断,会提前终止一个程序,可以通过ctrl+c产生中断.
    - 下表所列信号可以在程序中捕获:
      <img src="../image/screenshot_signal.png" width="70%" height="70%" />
    - C++信号处理库提供signal函数来捕获突发/中断事件.
      > 例: `signal(SIGINT, signalHandler);`  //捕获到ctrl+c中断时执行signalHandler函数.
    - raise()函数:其可以生成突发/中断信号.
      > 例: `raise( SIGINT);` // 可以产生一个与ctrl+c效果相同的一个中断.
11. **异常处理:**
    - C++异常是指在程序运行时发生的特殊情况,比如尝试除以零操作.
    - C++异常处理涉及到三个关键字:
      > throw: 当出现问题时,程序会抛出一个异常.
      > catch: 用于捕获异常,可以捕获C++标准内置的异常(定义在\<exception>中)),也可以自定义异常.
      > try: try块中放置可能抛出异常的代码,try块中的代码被称为**保护代码**.
12. **动态内存:**
    - C++程序中的内存分为两部分:
      > - 栈: 在函数内部声明的所有变量都占用栈内存.
      > - 堆: 用于动态内存分配.
    - 很多时候,我们无法提前预知需要多少内存来存储某个定义变量中的特定信息,所需内存的大小需要在运行时才能确定,这时就需要分配堆中的内存,使用new和delete运算符.
      > 例: `int *array=new int [m];`  //动态分配,数组长度为 m
13. **模板:**
    [模板讲解](https://blog.csdn.net/lms1008611/article/details/81985815)
    - 人们需要编写多个形式和功能都相似的函数或类, 于是C++引人了**函数模板**和**类模板**, 编译器从函数模板和类模板可以自动生成多个函数和类，避免了程序员的重复劳动.
      例: ./template/template.c
    * 函数模板:
    > 函数模板可以用来创建一个通用的函数，以支持多种不同的形参，避免重载函数的函数体重复设计.
    ```
      template<typename(或class) T>
      <返回类型><函数名>(参数表)
      {
        函数体
      }
    ```
14. **智能指针:**
    - 动态内存管理经常会出现两种问题: 一种是忘记释放内存, 会造成内存泄漏; 一种是尚有指针引用内存的情况下就释放了它, 就会产生引用非法内存的指针.
    - 为了更加容易（更加安全）的使用动态内存, 引入了智能指针的概念. 智能指针的行为类似常规指针, 重要的区别是它负责自动释放所指向的对象.
    - 智能指针分类:
      > unique_ptr: 持有对对象的独有权, 即unique_ptr不共享它所管理的对象(两个unique_ptr不能指向一个对象).
      > shared_ptr: 共享所有权的智能指针，允许多个指针指向同一个对象.
      > weak_ptr: 不控制所指向对象生存期的智能指针，它指向一个由shared_ptr管理的对象，将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放，即使有weak_ptr指向对象，对象还是会被释放.
15. **引用:**
    - 引用不是对象, 而是一个对象的一个别名.
    - 定义指针时编译器会自动分配内存, 而引用不会单独分配空间.
    - 指针作为参数时, 会拷贝指针作为参数, 由于指针指向的是一个对象, 因此在函数内可以实现对指针所指向对象的修改. 引用作为参数时, 实际是传递对象的本身因此不需要拷贝. 
16. **vector:**
    - vector将元素存储在连续内存空间中, 当添加的元素超过原先分配的内存大小时, 就需要重新申请空间, 并把原来的元素移到新的内存中. 通常vector实现通常会比空间需求分配更大的空间, 以避免在添加元素时频繁的重新分配空间并对数据进行移动.
17. **class**和**struct**: 本质没有区别(都可以定义类), 只是默认访问控制权限不同(class默认为private, struct默认为public)
18. **sizeof**: 其是操作符而不是函数, 结果为参数数据占用的空间大小而不是参数维数.
    **strlen**: 从参数所指向的内存开始往后计数, 直到内存中的内容为0(即'\0').
    **string**: 字符串是以'\0'结尾的字符数组.

    <table><tr><td bgcolor=AntiqueWhite>char *str3 = "hello";//最后有一个”隐形“的'\0'
    
    printf("test3 %lu %lu\n\n", sizeof(str3), strlen(str3)); //8 5
    注: str3并不是一个数组，而是一个字符指针, 因此sizeof(str3)为8, strlen还是从str3指向的地址开始，直到遇到’\0’，即得到长度5</td></tr></table>
    <table><tr><td bgcolor=AntiqueWhite> char str1[8] = "hello";
    
    printf("test1 %lu %lu\n\n", sizeof(str1), strlen(str1)); //8 5
    注: str1占用空间是8，而strlen仍然是5</td></tr></table>
    <table><tr><td bgcolor=AntiqueWhite> char str2[] = {'h','e','l','l','o'};
    
    printf("test2 %lu %lu\n\n", sizeof(str2), strlen(str2)); //5 10
    注: 在str2中没有看到'\0'，所以你可能看到的结果是10，也可能是另外一个莫名其妙的值，甚至可能导致程序崩溃</td></tr></table>
    <table><tr><td bgcolor=AntiqueWhite> char str4[] = "hello";
    
    testArr(str4);//8 5 
    注: 当数组作为参数时，实际上只是一个指针，所以用sizeof计算时，会得到8</td></tr></table>
    <table><tr><td bgcolor=AntiqueWhite> char str6[10] = {0};
    
    printf("test6 %lu %lu\n\n", sizeof(str6), strlen(str6)); //10 0
    注: sizeof结果为10，但是由于都是0，因此strlen得到长度位0</td></tr></table>
    <table><tr><td bgcolor=AntiqueWhite> char str7[5] = "hello";
    
    printf("test7 %lu %lu\n\n", sizeof(str7), strlen(str7)); //5 10
    注: sizeof结果是5，它没有空间容纳最后的’\0’, 因此导致strlen计算的结果和test2一样，可能会是任意值</td></tr></table>

19. **const用法:**
	参考资料[链接](https://www.jb51.net/article/118141.htm)
	1. 修饰常量:
	> * 基本原则: const 变量不可修改.
	2. const与指针:
	> const与指针的关系分为两种: 
	> * `const int* val`或`int const *val`: 可以改变指针指向，不能改变所指变量的值.
	> * `int* const val`: 不能改变指针指向，可以改变所指变量的值.
	> 总结: **左定值, 右定向**
    3. const修饰类对象:
	> * 基本原则: const修饰类对象时，其对象中的任何成员都不能被修改. const修饰的对象，该对象的任何非const成员函数都不能调用该对象，因为任何非const成员函数都会有修改成员变量的可能.
	4. const修饰类的成员变量
	> * 基本原则: const修饰的成员变量不能被修改，同时只能在初始化列表中被初始化，因为常量只能被初始化，不能被赋值.
	5. const修饰类的成员函数:
	> * 基本原则: 不能修改对象中的成员变量, 也不能调用类中任何非const成员函数(因为调用非const成员函数可能会修改对象中的成员变量).

20. **const常量与define宏定义的区别:**
	1. 处理阶段不同:
	> define是在预处理阶段，define常量从未被编译器看见，因为在预处理阶段就已经替换了. 而const常量在编译阶段使用.
	2. 类型和安全检查不同:
	> define没有类型，不做任何检查，仅仅是字符替换，没有类型安全检查，并且在字符替换时可能会产生意料不到的错误. const常量有明确的类型，在编译阶段会进行类型检查.
	3. 存储方式不同:
	> define是字符替换，有多少地方使用，就会替换多少次，不会分配内存. 编译器通常不会为const常量分配空间，只是将它们保存在符号表内，使他们成为一个编译期间的一个常量，没有读取内存的操作，效率也很高.
	
21. **static作用:**
	参考资料[链接](https://www.jianshu.com/p/321afbde1b48)
	1. 全局静态变量: 
   	> * 在全局变量前加关键字static, 全局变量就定义成为一个全局静态变量.
	> * 内存中位置: 静态存储区(在整个程序运行期间一直存在)
	> * 初始化: 未经初始化的全局静态变量会被自动初始化为0(自动对象的值是任意值)
	> * 静态全局变量与普通全局变量的区别在于: 全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾．其他文件中可以定义相同名字的变量，不会产生冲突. 
	> 例: 加了static关键字的全局变量只能在本文件中使用. 例如在a.c中定义了static int a=10;那么在b.c中用extern int a是拿不到a的值得，a的作用域只在a.c中.

    2. 局部静态变量: 
   	> * 在局部变量前加上关键字static, 局部变量就变成一个局部静态变量.
	> * 内存中位置: 静态存储区
	> * 初始化: 未经初始化的全局静态变量会被自动初始化为0(自动对象的值是任意值)
	> * 作用域: 作用域仍为局部作用域，当定义它的函数或语句块结束的时候，作用域结束．但是当局部静态变量离开作用域后并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变．
 
    3. 静态函数: 
	> * 在函数返回类型前加关键字static, 函数就定义为静态函数. 函数的定义和声明在默认情况下都是extern的, 静态函数与普通函数不同，它只能在声明它的文件中可见，不能被其他文件所使用.
	> 定义静态函数的好处在于: 静态函数不能被其他文件使用, 其他文件中可以定义相同名字的函数，不会发生冲突.

	4. 类的静态成员:
	> * 相对于非静态数据成员(每个实例都会有一个数据成员的拷贝), 静态数据成员在程序中有且仅有一个拷贝, 由该类型的实例对象所共享. 也就是说，**静态数据成员是该类的所有对象共有的**. 
	> * 因为静态数据成员在全局区，属于类所有对象共享，所以，它不属于特定的实例，在没有产生类实例的作用域也可见，即在没有产生类实例时，我们就可以操作它.
	> * 与全局变量相比，静态数据成员具有两个优势: 第一，静态数据成员没有进入程序的全局命名空间，所以不存在与其他名字冲突的可能性，另外一点，静态数据成员可以是private成员，而全局变量不行，从这一方面说，静态数据成员维护了类的封装性.

	5. 类的静态函数:
	> * 与静态数据成员一样，我们可以为类创建静态成员函数，它为类的全部实例服务．
	> * 静态成员函数的this指针是缺省的，这很好理解，因为其并不属于某一个对象; 而普通成员函数一般都隐藏了一个指向自身的this指针.
	> * 因为静态成员函数的this指针是缺省的，所以其没办法访问类的非静态成员函数（联系this指针的作用），只能访问类的静态数据成员和静态成员函数.
	> * 因为静态成员函数的this指针是缺省的，所以不能将其定义为虚函数，因为虚函数表需要通过this指针访问。同理静态成员变量也无法使用虚函数.

	**注: 对一个类中成员变量和成员函数来说，加了static关键字，则此变量/函数就没有了this指针了，必须通过类名才能访问.**

22. **指针和引用的区别:**
	1. 指针有自己的一块空间, 而引用只是一个别名.
	2. 使用sizeof看一个指针大小为8(64为操作系统), 而引用则是被引用对象的大小.
	3. 指针可以被初始化为NULL, 而引用必须被初始化且必须是一个已有对象的引用.
	4. 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象.

23. **数组和链表的区别:**
	参考资料[链接](https://www.nowcoder.com/tutorial/93/2550f96bf7034399a3eb6dd3dafdce82)
	1. 数组: 
	> * 数组将元素在内存中连续存放, 可以通过下标快速访问数组中的任何元素. 数组在非末尾插入和删除数据效率低, 插入和删除数据时都会产生数据在内存中的移动和拷贝.
	2. 链表:
	> * 链表中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起. 如果要访问链表中一个元素，需要从第一个元素开始，一直找到需要的元素位置. 但是增加和删除一个元素对于链表数据结构就非常简单了，只要修改元素中的指针就可以了. 

24. **C++内存管理:**
	参考资料[链接](https://www.jianshu.com/p/19771f5a89ea)
	1. 栈区(stack): 存放为运行时函数分配的局部变量、函数参数、返回数据、返回地址等. 函数执行结束后栈区自动释放. 栈内存分配效率高，由操作系统和编译器自动分配，但存储空间有限.
	2. 堆区(heap): 调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存, 否则可能会发生内存泄露和内存越界情况.
	3. 全局区(静态区): 存储程序的全局变量和静态变量.
	4. 常量区: 常量区内存空间存储常量（包括字符串等内容）.
	5. 代码区: 代码区存放函数体的二进制代码.

25. **静态链接库与动态链接库:**
    1. 当程序与静态库链接时，库中所有的目标文件都会被copy到可执行文件中，造成代码量增多. 而动态库是在运行时才将代码copy到内存中.
    2. 因为静态库是在编译的时候就已经完成copy，所以运行速度快，而动态库是在运行的时候才拷贝需要的函数，所以运行速度慢（可以理解为静态库是以空间换了时间）.
    3. 动态库是被多个程序共享，而静态库是每个程序拥有自己的一份copy.
    4. 如果需要对程序中的库进行修改和优化，使用动态库只需要重新将库编译即可；而使用静态库则需要将依赖静态库的文件都重新编译.

26. **inline函数的作用:**
	1. 优点: 指定为内联函数避免频繁调用消耗大量的栈空间。将函数指定为inline，就是在其调用位置展开，从而能对提高运行效率(不用再去寻找函数的实现).
	2. 缺点: 在调用位置展开从而也决定了内联函数的缺点，增大了代码量，从而消耗了内存空间.

27. **extern关键字的作用:**
	告诉编译器，这是一个全局变量或函数，如果在本文件中没有找到相应的变量或函数，可以在后面或其他文件中寻找.

28. **哪些情况下必须使用初始化列表:**
	1. 初始化类的成员有两种方式，一是使用初始化列表，二是在构造函数体内进行赋值操作. 使用初始化列表主要是基于性能问题.
	2. 常量成员，引用类型成员必须采用初始化列表形式，因为这两种成员只能初始化，不能赋值.
	3. 对于没有构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来完成初始化, 而直接调用拷贝构造函数初始化，这样是非常高效的.

29. **指针函数和函数指针:**
	1. 指针函数，简单的来说，就是一个返回指针的函数，其本质是一个函数，而该函数的返回值是一个指针.
	> 例: `int *fun(int x,int y)`
	2. 函数指针: 指向函数入口地址的指针. **指向函数的指针变量不是固定指向哪一个函数的，而只是表示定义了一个这样类型的变量，它是专门用来存放函数的入口地址的; 在程序中把哪一个函数的地址赋给它，它就指向哪一个函数**.
	> * 参考资料[链接1](https://www.jianshu.com/p/405a81d8e7b4)
	> * 参考资料[链接2](https://www.jianshu.com/p/6e858052b0f9)
	> * 格式: 类型名 (*指针变量名)(函数参数列表)
	> * 函数指针的用途: 调用函数和做函数的参数.

30. **#和##区别:**
	参考资料[链接](https://www.jianshu.com/p/595bd0d4eff3)
	> #: 预处理阶段进行替换.
	> ##: 将##前面与##后面的内容做连接，构成一个新的值，这个新的值不是一个字符串.

31. **单引号(')和双引号("):**
	> 单引号: 表明单个字符.
	> 双引号: 表示字符串.

32. **野指针:**
	> 1. 定义: 指向一个已删除的对象或未申请访问受限内存区域的指针.
	> 2. 产生原因: 
	> * 未初始化指针变量: 
	`int i = 3;`
	`int* p;`
	`*p=i;`  //野指针, p指向的内存访问受限. 因为指针未初始化，**指向的内存块是随机的**.
	> * 指针释放后之后未置空(悬空指针).
	`int i = 3;`
	`int* p = new int[3]`
	`delete [] a;`
	`*p = 3; `  // 野指针, p指向的内存访问受限. 此内存块已被delete释放.

33. **register关键字:**
	> 1. register关键字请求编译器将变量尽可能存储在CPU内部存储器中, 而不是通过内存寻址访问, 以提高效率. 
		注: 如果定义了很多register变量, 可能会超过CPU的寄存器个数, 超过容量, 因此是尽可能.
	> 2. register修饰的几点限制:
	> * register变量必须是能被CPU所接受的类型. 这通常意味着register变量必须是一个单个的值，并且长度应该小于或者等于整型的长度. 不过，有些机器的寄存器也能存放浮点数.
    > * 因为register变量可能不存放在内存中，所以不能用“&”来获取register变量的地址. 由于寄存器的数量有限，而且某些寄存器只能接受特定类型的数据（如指针和浮点数），因此真正起作用的register修饰符的数目和类型都依赖于运行程序的机器，而任何多余的register修饰符都将被编译程序所忽略. 在某些情况下，把变量保存在寄存器中反而会降低程序的运行速度. 因为被占用的寄存器不能再用于其它目的; 或者变量被使用的次数不够多，不足以装入和存储变量所带来的额外开销.
    > * 早期的C编译程序不会把变量保存在寄存器中，除非你命令它这样做，这时register修饰符是C语言的一种很有价值的补充. 然而，随着编译程序设计技术的进步，在决定那些变量应该被存到寄存器中时，现在的C编译环境能比程序员做出更好的决定. 实际上，许多编译程序都会忽略register修饰符，因为尽管它完全合法，但它仅仅是暗示而不是命令.
	> 3. **C++编译器有自己的优化方式，即使不使用register关键字编译器也会自动优化.**

34. **override关键字:**
	参考资料[链接](http://c.biancheng.net/view/1561.html)
	> override关键字告诉编译器, 该函数应该覆盖基类中的函数. 如果该函数实际上没有覆盖任何函数, 则会导致编译器报错.

35. **STL--string类**
* C++ 从 C 继承的字符串概念仍然是以 '\0' 为结束符的 char 数组。
* 字符串中元素的访问可使用两种方法访问字符串中的单一字符：下标操作符[] 和成员函数at()，两者区别：
  > 1）下标操作符 [] 在使用时不检查索引的有效性
	> 2) 函数 at() 在使用时会检查下标是否有效。
* find() 函数和没有搜索到期望的字符（或子串），则返回 npos；若搜索成功，则返回搜索到的第 1 个字符或子串的位置

36. **STL--容器**
容器资料[链接](http://c.biancheng.net/stl/sequence_container/)
* array<T,N> (数组容器) ：是一个长度固定的序列，有 N 个 T 类型的对象，不能增加或删除元素。
* vector<T> (向量容器) ：是一个长度可变的序列，用来存放T类型的对象。必要时，可以自动增加容量，但只能在序列的末尾高效地增加或删除元素。
* deque<T> (双向队列容器) ：是一个长度可变的、可以自动增长的序列，在序列的两端都不能高效地增加或删除元素。
* list<T> (链表容器) 是一个长度可变的、由 T 类型对象组成的序列，它以双向链表的形式组织元素，在这个序列的任何地方都可以高效地增加或删除元素。访问容器中任意元素的速度要比前三种容器慢，这是因为 list<T> 必须从第一个元素或最后一个元素开始访问，需要沿着链表移动，直到到达想要的元素。
* forward list<T> (正向链表容器) ：是一个长度可变的、由 T 类型对象组成的序列，它以单链表的形式组织元素，是一类比链表容器快、更节省内存的容器，但是它内部的元素只能从第一个元素开始访问。

37. **STL--map容器**
**map容器资料[链接](http://c.biancheng.net/stl/map/)** ,map容器是一种关联容器，对象的位置取决于和它关联的键的值。
**map容器有四种：**
  > 1. map<K,T>: 保存pair<const K,T>类型的元素。map容器中的每个键值都是唯一的，不允许有重复的键值，可以进行一对一或者一对多的映射。map容器中的元素都是有序的，元素在容器中内的顺序是通过比较键确定的。
	> 2. multimap<K,T>:与map<K,T>容器类似，也会对元素排序。不通点在于multimap容器允许使用重复的键值。
	> 3. unordered_map<K,T>:其中的pair<const K,T>元素的顺序并不是由键值确定的，而是由键值的哈希表决定的。
	> 4. unordered_map<K,T>:也可以通过键值生成的哈希值来确定对象的位置，允许有重复的键值。

38. **map容器：**
- map<K,T>每个T类型的对象都有一个关联的K类型的键。容器内对象的位置是通过比较键决定的,map 使用 less<K> 对元素排序。
- STL map 容器对元素的组织方式并没有具体要求，但元素一般都会保存在一个平衡二叉树中。容器中的元素被组织成一个平衡二叉树，因而树的高度——根节点和叶节点之间的高度是最低的。如果每个节点的左子树和右子树的高度差不超过 1，那么可以说这棵二叉树就是平衡的。
- map<K，T> 中的每个元素都是同时封装了对象及其键的 pair<const K，T> 类型对象，这里不能修改 const K，否则会影响容器结构。
- map元素创建函数：
	> pair<const K,T>和make_pair:插入map中不存在的元素。例：std::pair<char,int>('a',100)
	> make_pair <T1,T2>()  例：std::make_pair("Ann",25)
- map插入元素函数：
  > 成员函数 insert():返回一个 pair<iterator,bool> 对象。对象的成员 first 是一个map<K,T>迭代器, 它要么指向插入元素，要么指向阻止插入的元素。如果 map 中已经保存了一个和这个键相同的对象，就会出现后面这种情况。这个对象的成员变量 second (布尔型)是返回对象，如果插入成功，返回值为 true，否则为 false。
- map获取元素函数：
  > 成员函数 at() 返回的是参数键对应的对象。如果这个键不存在，就会拋出 out_of_range 异常。
	> 成员函数 find() 可以返回一个元素的迭代器，这个元素的键值和对象匹配。
- map删除元素函数：
  > 成员函数erase(): 通过迭代器或键值删除元素
- map迭代器：
  > for (std::map<char,int>::iterator it=mymap.begin(); it!=mymap.end(); ++it)
				std::cout << it->first << " => " << it->second << '\n';

39. **emplace_back()取代push_back():**
> push_back()函数向容器中加入一个临时对象时，首先会调用构造函数生成这个对象，然后调用拷贝构造函数将这个对象放入容器中，最后释放临时对象。
> emplace_back()函数向容器中加入临时对象，临时对象原地构造，没有赋值或移动的操作。
**emplace()与insert():**
> 与上例相同
**综上：emplace_back()/emplace()相比push_back()/insert()最大的作用是避免了不必要的临时变量，因此执行速度快、效率更高。**

40. **virtual析构函数**:
> 定义一个父类的指针，指向子类对象，而在delete 父类指针时，期望释放对象。但父类析构函数不加Virtual修饰，则只会调用父类析构函数，而不调用子类析构函数，导致只释放了对象的父类部分，而子类部分没有释放.

41. **explicit关键字:**
> 主要是用来修饰类的构造函数，表明该构造函数是显式的，禁止单参数构造函数的隐式转换, 即如果c++类的其中一个构造函数有一个参数，那么在编译的时候就会有一个缺省的转换操作：将该构造函数对应数据类型的数据转换为该类对象。
[explicit讲解](https://www.jb51.net/article/101557.htm)

42. **C++类中的特殊成员函数:**
  六个函数特殊成员函数分别是：  
  * 默认构造函数
    > 默认构造函数指不需要参数就能初始化的构造函数。包含无参和所有参数有默认值两种类型的构造函数。
  * 复制构造函数
    > 复制构造函数指使用该类的对象作为参数的构造函数。可以有其他参数，但必须提供默认值。
  * 复制赋值运算符
    > 重载等号=，将该类的对象赋值给已定义对象。
  * 析构函数
  * 移动构造函数
    > C++11新增，该类的右值对象为参数的构造函数，其余同复制构造函数。
  * 移动复制运算符
    > 同复制赋值运算符，唯一不同是参数为右值。
  **C++11新增了=default和=delete函数修饰符，提示编译器使用默认或者删除默认的特殊函数。需要注意的是这两个修饰符只能修饰上述特殊函数.**
  [default讲解](https://mp.weixin.qq.com/s?__biz=MzI2OTA3NTk3Ng==&mid=2649284831&idx=1&sn=177853e985bb3d443b736e7f63152a9d&chksm=f2f993b8c58e1aae2f353beefa1dd30b50ec5ecde2e9f18a5af799286deb5a125305b5232b00&mpshare=1&scene=1&srcid=0326Mq0sWvh9bTYMTlZumlTn&sharer_sharetime=1585311683398&sharer_shareid=87c63c66f42a4150bca9a3d2a69b5061&exportkey=AxJXk5ZcW%2B1aJ7YUQJGB0%2BI%3D&pass_ticket=QGB2T9QUKj9%2FDBqTZFRux2fE2MBP33SOaQpnm2b6PMup%2BAIscHX8wNq7hY6vPvW%2F#rd)

43. **多进程和多线程:**
  * 基于进程的多任务处理是**程序的并发执行**.
  * 基于线程的多任务处理是同一**程序的片段的并发执行**.
  > 多线程程序包含可以同时运行的两个或多个部分。这样的程序中的每个部分称为一个线程，每个线程定义了一个单独的执行路径.
  > 多个线程访问同一资源时，为了保证数据的一致性，最简单的方式就是使用 mutex（互斥锁）.
  [互斥锁讲解](https://www.cnblogs.com/zhanghu52030/p/9166737.html)
