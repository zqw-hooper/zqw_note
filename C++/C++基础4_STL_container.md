# C++基础-4

## STL--string类
* C++ 从 C 继承的字符串概念仍然是以 '\0' 为结束符的 char 数组。
* 字符串中元素的访问可使用两种方法访问字符串中的单一字符：下标操作符[] 和成员函数at()，两者区别：
  > 1）下标操作符 [] 在使用时不检查索引的有效性
	> 2) 函数 at() 在使用时会检查下标是否有效。
* find() 函数和没有搜索到期望的字符（或子串），则返回 npos；若搜索成功，则返回搜索到的第 1 个字符或子串的位置


## STL--容器
容器资料[链接](http://c.biancheng.net/stl/sequence_container/)
* array<T,N> (数组容器) ：是一个长度固定的序列，有 N 个 T 类型的对象，不能增加或删除元素。
* vector<T> (向量容器) ：是一个长度可变的序列，用来存放T类型的对象。必要时，可以自动增加容量，但只能在序列的末尾高效地增加或删除元素。
* deque<T> (双向队列容器) ：是一个长度可变的、可以自动增长的序列，在序列的两端都不能高效地增加或删除元素。
* list<T> (链表容器) 是一个长度可变的、由 T 类型对象组成的序列，它以双向链表的形式组织元素，在这个序列的任何地方都可以高效地增加或删除元素。访问容器中任意元素的速度要比前三种容器慢，这是因为 list<T> 必须从第一个元素或最后一个元素开始访问，需要沿着链表移动，直到到达想要的元素。
* forward list<T> (正向链表容器) ：是一个长度可变的、由 T 类型对象组成的序列，它以单链表的形式组织元素，是一类比链表容器快、更节省内存的容器，但是它内部的元素只能从第一个元素开始访问。


## STL--map容器
**map容器资料[链接](http://c.biancheng.net/stl/map/)** ,map容器是一种关联容器，对象的位置取决于和它关联的键的值。
### map容器有四种：
  > 1. map<K,T>: 保存pair<const K,T>类型的元素。map容器中的每个键值都是唯一的，不允许有重复的键值，可以进行一对一或者一对多的映射。map容器中的元素都是有序的，元素在容器中内的顺序是通过比较键确定的。
	> 2. multimap<K,T>:与map<K,T>容器类似，也会对元素排序。不通点在于multimap容器允许使用重复的键值。
	> 3. unordered_map<K,T>:其中的pair<const K,T>元素的顺序并不是由键值确定的，而是由键值的哈希表决定的。
	> 4. unordered_map<K,T>:也可以通过键值生成的哈希值来确定对象的位置，允许有重复的键值。
### map容器：
- map<K,T>每个T类型的对象都有一个关联的K类型的键。容器内对象的位置是通过比较键决定的,map 使用 less<K> 对元素排序。
- STL map 容器对元素的组织方式并没有具体要求，但元素一般都会保存在一个平衡二叉树中。容器中的元素被组织成一个平衡二叉树，因而树的高度——根节点和叶节点之间的高度是最低的。如果每个节点的左子树和右子树的高度差不超过 1，那么可以说这棵二叉树就是平衡的。
- map<K，T> 中的每个元素都是同时封装了对象及其键的 pair<const K，T> 类型对象，这里不能修改 const K，否则会影响容器结构。
- map元素创建函数：
	> pair<const K,T>和make_pair:插入map中不存在的元素。例：std::pair<char,int>('a',100)
	> make_pair <T1,T2>()  例：std::make_pair("Ann",25)
- map插入元素函数：
  > 成员函数 insert():返回一个 pair<iterator,bool> 对象。对象的成员 first 是一个map<K,T>迭代器, 它要么指向插入元素，要么指向阻止插入的元素。如果 map 中已经保存了一个和这个键相同的对象，就会出现后面这种情况。这个对象的成员变量 second (布尔型)是返回对象，如果插入成功，返回值为 true，否则为 false。
- map获取元素函数：
  > 成员函数 at() 返回的是参数键对应的对象。如果这个键不存在，就会拋出 out_of_range 异常。
	> 成员函数 find() 可以返回一个元素的迭代器，这个元素的键值和对象匹配。
- map删除元素函数：
  > 成员函数erase(): 通过迭代器或键值删除元素
- map迭代器：
  > for (std::map<char,int>::iterator it=mymap.begin(); it!=mymap.end(); ++it)
				std::cout << it->first << " => " << it->second << '\n';



### emplace_back()取代push_back():
> push_back()函数向容器中加入一个临时对象时，首先会调用构造函数生成这个对象，然后调用拷贝构造函数将这个对象放入容器中，最后释放临时对象。
> emplace_back()函数向容器中加入临时对象，临时对象原地构造，没有赋值或移动的操作。
### emplace()与insert():
> 与上例相同

**综上：emplace_back()/emplace()相比push_back()/insert()最大的作用是避免了不必要的临时变量，因此执行速度快、效率更高。**