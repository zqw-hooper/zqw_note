# C++基础

- **const用法:**
	参考资料[链接](https://www.jb51.net/article/118141.htm)
	1. 修饰常量:
	> * 基本原则: const 变量不可修改.
	2. const与指针:
	> const与指针的关系分为两种: 
	> * `const int* val`或`int const *val`: 可以改变指针指向，不能改变所指变量的值.
	> * `int* const val`: 不能改变指针指向，可以改变所指变量的值.
    3. const修饰类对象:
	> * 基本原则: const修饰类对象时，其对象中的任何成员都不能被修改. const修饰的对象，该对象的任何非const成员函数都不能调用该对象，因为任何非const成员函数都会有修改成员变量的可能.
	4. const修饰类的成员变量
	> * 基本原则: const修饰的成员变量不能被修改，同时只能在初始化列表中被初始化，因为常量只能被初始化，不能被赋值.
	5. const修饰类的成员函数:
	> * 基本原则: 不能修改对象中的成员变量, 也不能调用类中任何非const成员函数(因为调用非const成员函数可能会修改对象中的成员变量).

- **const常量与define宏定义的区别:**
	1. 处理阶段不同:
	> define是在预处理阶段，define常量从未被编译器看见，因为在预处理截断就已经替换了. 而const常量在编译阶段使用.
	2. 类型和安全检查不同:
	> define没有类型，不做任何检查，仅仅是字符替换，没有类型安全检查，并且在字符替换时可能会产生意料不到的错误. const常量有明确的类型，在编译阶段会进行类型检查.
	3. 存储方式不同:
	> define是字符替换，有多少地方使用，就会替换多少次，不会分配内存. 编译器通常不会为const常量分配空间，只是将它们保存在符号表内，使他们成为一个编译期间的一个常量，没有读取内存的操作，效率也很高.
	
- **static作用:**
	参考资料[链接](https://www.jianshu.com/p/321afbde1b48)
	1. 全局静态变量: 
   	> * 在全局变量前加关键字static, 全局变量就定义成为一个全局静态变量.
	> * 内存中位置: 静态存储区(在整个程序运行期间一直存在)
	> * 初始化: 未经初始化的全局静态变量会被自动初始化为0(自动对象的值是任意值)
	> * 静态全局变量与普通全局变量的区别在于: 全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾．其他文件中可以定义相同名字的变量，不会产生冲突. 

    2. 局部静态变量: 
   	> * 在局部变量前加上关键字static, 局部变量就变成一个局部静态变量.
	> * 内存中位置: 静态存储区
	> * 初始化: 未经初始化的全局静态变量会被自动初始化为0(自动对象的值是任意值)
	> * 作用域: 作用域仍为局部作用域，当定义它的函数或语句块结束的时候，作用域结束．但是当局部静态变量离开作用域后并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变．
 
    3. 静态函数: 
	> * 在函数返回类型前加关键字static, 函数就定义为静态函数. 函数的定义和声明在默认情况下都是extern的, 静态函数与普通函数不同，它只能在声明它的文件中可见，不能被其他文件所使用.
	> 定义静态函数的好处在于: 静态函数不能被其他文件使用, 其他文件中可以定义相同名字的函数，不会发生冲突.

	4. 类的静态成员:
	> * 相对于非静态数据成员(每个实例都会有一个数据成员的拷贝), 静态数据成员在程序中有且仅有一个拷贝, 由该类型的实例对象所共享. 也就是说，**静态数据成员是该类的所有对象共有的**. 
	> * 因为静态数据成员在全局区，属于类所有对象共享，所以，它不属于特定的实例，在没有产生类实例的作用域也可见，即在没有产生类实例时，我们就可以操作它.
	> * 与全局变量相比，静态数据成员具有两个优势: 第一，静态数据成员没有进入程序的全局命名空间，所以不存在与其他名字冲突的可能性，另外一点，静态数据成员可以是private成员，而全局变量不行，从这一方面说，静态数据成员维护了类的封装性.

	5. 类的静态函数:
	> *　与静态数据成员一样，我们可以为类创建静态成员函数，它为类的全部实例服务．
	> * 静态成员函数的this指针是缺省的，这很好理解，因为其并不属于某一个对象；而普通成员函数一般都隐藏了一个指向自身的this指针.
	> * 因为静态成员函数的this指针是缺省的，所以其没办法访问类的非静态成员函数（联系this指针的作用），只能访问类的静态数据成员和静态成员函数.
	> * 因为静态成员函数的this指针是缺省的，所以不能将其定义为虚函数，因为虚函数表需要通过this指针访问。同理静态成员变量也无法使用虚函数.

- **指针和引用的区别:**
	1. 指针有自己的一块空间, 而引用只是一个别名.
	2. 使用sizeof看一个指针大小为8(64为操作系统), 而引用则是被引用对象的大小.
	3. 指针可以被初始化为NULL, 而引用必须被初始化且必须是一个已有对象的引用.
	4. 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象.

- **数组和链表的区别:**
	参考资料[链接](https://www.nowcoder.com/tutorial/93/2550f96bf7034399a3eb6dd3dafdce82)
	1. 数组: 
	> * 数组将元素在内存中连续存放, 可以通过下标快速访问数组中的任何元素. 数组在非末尾插入和删除数据效率低, 插入和删除数据时都会产生数据在内存中的移动和拷贝.
	2. 链表:
	> * 链表中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起. 如果要访问链表中一个元素，需要从第一个元素开始，一直找到需要的元素位置. 但是增加和删除一个元素对于链表数据结构就非常简单了，只要修改元素中的指针就可以了. 

- **C++内存管理:**
	参考资料[链接](https://www.jianshu.com/p/19771f5a89ea)
	1. 栈区(stack): 存放为运行时函数分配的局部变量、函数参数、返回数据、返回地址等. 函数执行结束后栈区自动释放. 栈内存分配效率高，由操作系统和编译器自动分配，但存储空间有限.
	2. 堆区(heap): 调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存, 否则可能会发生内存泄露和内存越界情况.
	3. 全局区(静态区): 储程序的全局变量和静态变量.
	4. 常量区: 常量区内存空间存储常量（包括字符串等内容）.
	5. 代码区: 代码区存放函数体的二进制代码.

- **静态链接库与动态链接库:**
    1. 当程序与静态库链接时，库中所有的目标文件都会被copy到可执行文件中，造成代码量增多；而动态库是在运行时才将代码copy到内存中.
    2. 因为静态库是在编译的时候就已经完成copy，所以运行速度快，而动态库是在运行的时候才拷贝需要的函数，所以运行速度慢（可以理解为静态库是以空间换了时间）.
    3. 动态库是被多个程序共享，而静态库是每个程序拥有自己的一份copy.
    4. 如果需要对程序中的库进行修改和优化，使用动态库只需要重新将库编译即可；而使用静态库则需要将依赖静态库的文件都重新编译.

- **inline函数的作用:**
	1. 优点: 指定为内联函数避免频繁调用消耗大量的栈空间。将函数指定为inline，就是在其调用位置展开，从而能对提高运行效率(不用再去寻找函数的实现).
	2. 缺点: 在调用位置展开从而也决定了内联函数的缺点，增大了代码量，从而消耗了内存空间.

- **extern关键字的作用:**
	告诉编译器，这是一个全局变量或函数，如果在本文件中没有找到相应的变量或函数，可以在后面或其他文件中寻找.

- **哪些情况下必须使用初始化列表:**
	1. 初始化类的成员有两种方式，一是使用初始化列表，二是在构造函数体内进行赋值操作. 使用初始化列表主要是基于性能问题.
	2. 常量成员，引用类型成员必须采用初始化列表形式，因为这两种成员只能初始化，不能赋值.
	3. 对于没有构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来完成初始化, 而直接调用拷贝构造函数初始化，这样是非常高效的.

- **指针函数和函数指针:**
	1. 指针函数，简单的来说，就是一个返回指针的函数，其本质是一个函数，而该函数的返回值是一个指针.
	> 例: `int *fun(int x,int y)`
	2. 函数指针: 指向函数入口地址的指针称为函数指针. **指向函数的指针变量不是固定指向哪一个函数的，而只是表示定义了一个这样类型的变量，它是专门用来存放函数的入口地址的；在程序中把哪一个函数的地址赋给它，它就指向哪一个函数**.
	> * 参考资料[链接1](https://www.jianshu.com/p/405a81d8e7b4)
	> * 参考资料[链接2](https://www.jianshu.com/p/6e858052b0f9)
	> * 格式: 类型名 (*指针变量名)(函数参数列表)
	> * 函数指针的用途: 调用函数和做函数的参数.
