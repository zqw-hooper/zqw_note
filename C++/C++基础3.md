# C++基础-3

- **#和##区别:**
	参考资料[链接](https://www.jianshu.com/p/595bd0d4eff3)
	> #: 预处理阶段进行替换.
	> ##: 将##前面与##后面的内容做连接，构成一个新的值，这个新的值不是一个字符串.
- **单引号(')和双引号("):**
	> 单引号: 表明单个字符.
	> 双引号: 表示字符串.
- **野指针:**
	> 1. 定义: 指向一个已删除的对象或未申请访问受限内存区域的指针.
	> 2. 产生原因: 
	> * 未初始化指针变量: 
	`int i = 3;`
	`int* p;`
	`*p=i;`  //野指针, p指向的内存访问受限. 因为指针未初始化，**指向的内存块是随机的**.
	> * 指针释放后之后未置空(悬空指针).
	`int i = 3;`
	`int* p = new int[3]`
	`delete [] a;`
	`*p = 3; `  // 野指针, p指向的内存访问受限. 此内存块已被delete释放.
- **register关键字:**
	> 1. register关键字请求编译器将变量尽可能存储在CPU内部存储器中, 而不是通过内存寻址访问, 以提高效率. 
		注: 如果定义了很多register变量, 可能会超过CPU的寄存器个数, 超过容量, 因此是尽可能.
	> 2. register修饰的几点限制:
	> * register变量必须是能被CPU所接受的类型. 这通常意味着register变量必须是一个单个的值，并且长度应该小于或者等于整型的长度. 不过，有些机器的寄存器也能存放浮点数.
    > * 因为register变量可能不存放在内存中，所以不能用“&”来获取register变量的地址. 由于寄存器的数量有限，而且某些寄存器只能接受特定类型的数据（如指针和浮点数），因此真正起作用的register修饰符的数目和类型都依赖于运行程序的机器，而任何多余的register修饰符都将被编译程序所忽略. 在某些情况下，把变量保存在寄存器中反而会降低程序的运行速度. 因为被占用的寄存器不能再用于其它目的; 或者变量被使用的次数不够多，不足以装入和存储变量所带来的额外开销.
    > * 早期的C编译程序不会把变量保存在寄存器中，除非你命令它这样做，这时register修饰符是C语言的一种很有价值的补充. 然而，随着编译程序设计技术的进步，在决定那些变量应该被存到寄存器中时，现在的C编译环境能比程序员做出更好的决定. 实际上，许多编译程序都会忽略register修饰符，因为尽管它完全合法，但它仅仅是暗示而不是命令.
	> 3. **C++编译器有自己的优化方式，即使不使用register关键字编译器也会自动优化.**
- **override关键字:**
	参考资料[链接](http://c.biancheng.net/view/1561.html)
	> override关键字告诉编译器, 该函数应该覆盖基类中的函数. 如果该函数实际上没有覆盖任何函数, 则会导致编译器报错.
