# Design Pattern(23种)

1. Singleton Pattern(单例模式)
    * 单例类只能有一个实例. [链接1](https://www.geeksforgeeks.org/singleton-design-pattern/?ref=rp) [链接2](https://blog.csdn.net/yuan_qh/article/details/99962482)
2. Factory Pattern(工厂模式)
    * 定义：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中.  
    * 分类：
      > * 简单工厂模式：[链接](http://c.biancheng.net/view/8385.html)  
        优点：工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例。客户端可以免除直接创建产品对象的职责，很方便的创建出相应的产品。客户端无需知道所创建具体产品的类名，只需知道参数即可.  
        缺点：系统扩展困难，一旦增加新产品不得不修改工厂逻辑.  
      > * 工厂方法模式：[链接](http://c.biancheng.net/view/1348.html)  
        为了解决简单工厂模式增加新产品时对工厂修改的缺点, 主要有两种解决方案：  
            1. 将简单工厂中的切换逻辑移至抽象产品中，使得增加新产品时工厂无需变动;  
            2. 增加抽象工厂，使得每次增加新产品时只需要多写一个相应的工厂类.  
      > * 抽象工厂模式：[链接](http://c.biancheng.net/view/1351.html)  
        抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品.  

3. Template Method Pattern(模板方法模式)
   * 定义：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤.  
   * 实现：模板方法模式需要注意抽象类与具体子类之间的协作。它用到了虚函数的多态性技术以及“不用调用我，让我来调用你”的反向控制技术.  
   * 模板方法模式包含：
    > 抽象方法：在抽象类中申明，由具体子类实现。
    > 具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。
    > **钩子方法**：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种.